# DP ? : Dynamic Programming 즉 동적 계획법이란 뜻이다.
'''
예전 나폴레옹은 1805년 아우스터리츠 전투에서 자신의 군대보다 큰 군대를 상대하게 되었다. 하지만 이때 진영을 퍼뜨려서 싸우게되면 숫자가 적어
불리했을텐데, 나폴레옹은 적진 중앙을 공략해서 반으로 가른 뒤 분할된 상대편을 공격하는 방식으로 승리하였다고 한다. 
 이렇게 나폴레옹이 사용한 방법을 Algorithm에서는 '분할정복 알고리즘' 이라고 하는데 더 자세히 알아보도록 하자. 
'''

# 동적계획법은 불필요한 연산으 줄이고 최적의 답안을 구하는 알고리즘이다. 
"""
1) 배낭 문제
: 배낭문제는 무게와 가격이 다른 여러 물건 중에서, 가장 효율적으로 배낭에 채우기 위한 문제다. 
 어디서 냄새가 스멀스멀 나지 않는가?... 앞장에서 봤던 동물원 문제랑 같다. 동물들의 무게와 값을 토대로 누굴 먼저 데려가는게 좋은지 계산하던 방법과 비슷하다.
 또한 Greedy 탐욕법에 거스름돈 계산 문제와도 비슷하다. 
 일단 살펴보면 보물 탐험가 철수는 보물섬에서 많은 보물들을 발견하였다. 하지만 배낭의 공간은 한정적이다. 이때 무엇을 갖고 나가는게 가장 최적일 것인가???
 <1> 금괴 (6kg 13억)
 <2> 수정 (4kg 8억)
 <3> 진주 (5kg 12억)
 <4> 루비 (3kg 6억)
 참고로 철수 가방은 7kg까지밖에 넣지 못한다.
------------------------------------------------------------------
2) 브루트 포스 검색 
: 브루트포스는 모든 경우의 수를 나열한 후 그중에서 최선의 해결책을 찾는 방법이다. Brute는 짐승, force는 힘을 뜻하므로, 
 그냥 무식하게 구구절절식으로 풀라는 뜻이다. 
 이 방법의 장점은 가장 좋은 결과를 '확실하게' 추출할 수 있다는 것에 있다.
 그럼 앞에 제시된 배낭 문제를 브루프포스로 풀면 어떻게 되는가?

 2-1) 아무것도 넣지 않는 경우 
: 무게 문제는 없으나, 아무런 소득도 없다. (최악의 방법)
 
 2-2) 보석을 하나씩만 넣는 경우
 : 모두 최대 무게를 넘지는 않지만, 하나만 넣을 경우 금괴 하나가 젤 값지다는 것을 알 수 있다.

 2-3) 보석을 2개씩 넣는 경우 
 : 수정+루비 조합만 제외하고 모두 최대 무게를 넘는다. 수정+루비의 최대 가격은 14억이므로 금괴 하나보다 더 값지다.

2-4) 보석을 3개씩 넣는 경우
: 이 방법은 어떻게 조합해도 한계를 넘기 때문에 존재하지 않는다.

2-5) 보석 4개를 모두 넣는 경우
: 이 방법도 2-4) 와 같다.

이렇게 모든 경우의 수를 따져봤을때, 가장 좋은 방법은 보석을 2개(루비+수정) 조합이 가장 용량별 이득이 크기때문에 적합하다.
 하지만 솔직히 수가 적고 용량이 적기때문에 가능했던 얘기고, 계산을 n번 한다는 가정하에 2^n의 계산이 필요한데 
 당장 n이 10이 되면 1024가지가 넘는다. 이걸 언제 다 계산할것인가...?
--------------------------------------------------------------------------------

3) 탐욕 알고리즘 (Greedy Algorithm)
: 이름 그대로 탐욕적으로 문제를 해결해나간단 뜻이다. 가장 큰 이익의 Data를 먼저 선택하고, 그 다음 이익이 큰 Data를 취하는 방식으로 선택한다.
 Greedy를 사용하면 가장 효과적인 결과를 얻는다 생각하겠지만, 꼭 그런것만은 아니다.
 앞에 제시된 배낭문제를 탐욕 알고리즘으로 해결해본다면, 

 3-1) 가장 가격이 높은 금괴를 배낭에 넣어보면.. 배낭이 7kg이므로 금괴(6kg)를 담을 수 있다.

 3-2) 그 후로 가격이 높은 진주 ->  수정 -> 루비 순으로 배낭에 넣어보지만 금괴 + 를 하게되면 모두 무게초과가 나게된다.

 3-3) 더 이상 시도할 필요가 없으므로, 처음에 넣었던 금괴 1개가 가장 적합하다는걸 알 수 있다.

 근데 뭔가 이상하지 않은가?? 앞서 브루트포스에서 모든 경우를 조사햇을 때는, 분명 루비+수정의 값이 가장 높게나왔었다.
 즉 이 방법은 틀렸다는 것을 알수있었다.
-----------------------------------------------------------------------------------

4) 주먹구구 방식과 그리디의 비교
주먹구구는 모든 경우의 수를 다 확인해보고 최선의 결과를 도출해보는 것과 달리
탐욕법은 눈앞에 가장 큰 이익에 잘못 빠지면 잘못된 결과가 도출될 수 있다. 하지만 적은 연산횟수로 무난한 결과를 얻을 수 있다는 점은 괜찮다.

예시로 보석 40개를 담아보려했지만... 주먹구구식으로는 2^40 = 1조가 넘는 바람에 엄두도 못내게 되었고, 탐욕법으로는 가방 무게가 늘지 않았으므로 1개밖에 못넣고 끝나버렸다...
"""

"""
앞에 브루트 포스(주먹구구)와 그리디(탐욕)를 소개했지만 사실 이 둘은 각각의 단점이 있었다. 
이 두 단점을 보완하기 위해 등장한 것이 바로 이 단원의 제목인 DP(Dynamic Programming) 동적계획법이다. 
 동적 계획법은 불필요한 연산을 줄이고 최적의 답안을 구하는 알고리즘이다.
 우선 큰 문제를 작은 문제로 단순화한 후 재귀적인 호출을 활용하여 전체 문제를 해결한다.

앞서 다룬 배낭문제를 DP로 처리해보자. 
 2차원 표 구성을 해야하는데 귀찮아서 생략하겠다. P494 
 행은 배낭에 넣은 물건의 최대개수(0~4)를 나타내고, 열은 배낭에 담을 수 있는 무게를 나타낸다.
 표 안에 노란색 부분은 물건을 넣었을 때 배낭에 들어있는 최대 가격이다. 그 후 모두 초기화한다.

배열 = [[0 for _ in range(8)] for _ in range(5)]
---------------------------------------------
이어서 물건이 1개일 때!

if (금괴 무게 > 현재 배낭 무게):
    배열[행][열] = 배열[행-1][열]

"""